#Problem: Given an array of integers, sort the array based on the frequency of the elements. Elements with higher frequency should come first. If two elements have the same frequency, maintain their original order.
"""
Input: [4, 4, 4, 2, 2, 8, 3, 3, 3, 3]

Output: [3, 3, 3, 3, 4, 4, 4, 2, 2, 8]

"""

list1 = [4, 4, 4, 2, 2, 8, 3, 3, 3, 3]
def sort_on_count(list1:list):
  raw ={}
  for i in list1:
    if i not in raw:
      raw[i] = 1
    else:
      raw[i] +=1
  sorted_items = sorted(raw.items(), key=lambda item: item[1])
  result = []
  for j in sorted_items:
    for k in range(j[-1]):
      result.append(j[0])
  return result[::-1]

# print(sort_on_count(list1))

# second Approach
from collections import Counter

def sort_on_count1(l):
  counts = Counter(l)
  # print(counts)
  return sorted(list1,key=lambda x: counts[x],reverse=True)

# print(sort_on_count1(list1))

"""
Problem: Given an integer array, move all zeroes to the end of it while maintaining the relative order of the non-zero elements.

Input: [0, 1, 0, 3, 12]

Output: [1, 3, 12, 0, 0]
"""

l1 = [0, 1, 0, 3, 12]

def move_zero(l1):
  count = 0
  result = []
  for i in l1:
    if i != 0:
      result.append(i)
    else:
      count += 1
  for i in range(count):
    result.append(0)
  return result


"""
Problem: Given a 2D matrix (a list of lists), return the transpose of the matrix. The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.

Input: [[1, 2], [3, 4]]

Output: [[1, 3], [2, 4]]

"""

# matrix = [
#     [1, 2, 3],
#     [4, 5, 6],
#     [7, 8, 9]
# ]
# print(zip(*matrix))
# for row in zip(*matrix):
#   print(list(row))

# Transpose using zip() and list comprehension
# list(row) converts each tuple generated by zip into a list
# transpose = [list(row) for row in zip(*matrix)]

# Print the transposed matrix
# for row in transpose:
#     print(row)

# this is with zip

# l = [[1, 2], [3, 4]]
# l1 = zip(l)
# print([list[row] for row in zip(l)])

# transpose of matrix own logic
inp = [[1, 2, 3], [4, 5, 6]]
expected = [[1, 4], [2, 5], [3, 6]]

def transpose_matrix(inp):
  rows = len(inp)
  temp =[]
  for mat in inp:
    for col in len(mat):
      pass

  pass

"""
Problem: Given a string consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only.
"""
s = "Hello World Python "
def length_of_last(s):
  s = s.strip()
  s1 = s.split(" ")
  return len(s1[-1])

# print(length_of_last(s))

"""
Valid Parentheses (Balanced Brackets)
Problem: Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if open brackets are closed by the same type of brackets and in the correct order.

Input: "({[]})" -> True, "([)]" -> False
"""
s= "({[]})"
def valid_brackets(s):
  brackets = {"}":"{",")":"(","]":"["}
  stack =[]
  for i in s:
    if i not in brackets:
      stack.append(i)
    else:
      top_element = stack.pop() if stack else "#"
      if brackets[i] != top_element:
        return False
  return not stack

# print(valid_brackets(s))

"""
Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "".
"""

s = ["flower", "flow", "flight"]



def longest_comman_string(s):
  s1 = sorted(s)
  temp = 0
  ans = ""
  status = True
  while status:
    if status == False:
      break
    else:
      if s1[0][temp] == s1[-1][temp]:
        ans += s1[0][temp]
        temp += 1
      else:
        status = False
        return ans
  return ans

"""
Roman Symbols: I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000

Input: "MCMXCIV"

Output: 1994
"""

# need to convert romen into integer
  

romen = {
  "I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000
}

check = "MCMXCIV"   

# temp = romen.get(check[0])
# list1 = [temp]
# for char in range(1,len(check)):
#   value = romen.get(check[char])
#   if value > temp :
#     list1.append(value-temp)
#   else:
#     temp = value
# print(sum(list1))

def convert_romen_to_integer(s):
  roman = {
              "I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000
            }
  total = 0
  for i in range(len(s)):
      if i + 1 < len(s) and roman[s[i]] < roman[s[i+1]]:
          total -= roman[s[i]]
      else:
          total += roman[s[i]]
          
  return total
 
  
# print(convert_romen_to_integer(check))

"""
Problem: [1, 2, 3, 4] -> [24, 12, 8, 6]Index 0: $2 \times 3 \times 4 = 24$Index 1: $1 \times 3 \times 4 = 12$
"""
s = [1, 2, 3, 4]
ans = []
for i in range(len(s)):
  prod = 1
  for j in range(len(s)):
    if i == j :
      pass
    else:
      prod *= s[j]
  ans.append(prod)

def product_except_self(nums):
    n = len(nums)
    res = [1] * n
    left_prod = 1
    for i in range(n):
        res[i] = left_prod
        left_prod *= nums[i]
    right_prod = 1
    for i in range(n-1, -1, -1):
        res[i] *= right_prod
        right_prod *= nums[i]
        
    return res

# print(product_except_self([1, 2, 3, 4]))

"""
[[1, 3], [2, 6], [8, 10]] Yahan 1-3 aur 2-6 overlap kar rahe hain (kyunki 2, 3 se chota hai). Toh in dono ko jod kar [1, 6] kar dena hai."""

def merge_intervels(intervals):
  if not intervals:
    return []
  intervals.sort(key=lambda x:x[0])
  merged = [intervals[0]] # Pehla interval daal do
    
  for i in range(1, len(intervals)):
      current_start, current_end = intervals[i]
      last_end = merged[-1][1]
      if current_start <= last_end:
          merged[-1][1] = max(last_end, current_end)
      else:
          merged.append([current_start, current_end])
          
  return merged

# print(merge_intervels([[1, 3], [2, 6], [8, 10]]))

def pivot(l):
  total_sum = sum(l)
  left_sum = 0
  for i in range(len(l)):
    right_sum = total_sum - left_sum - l[i]

    if left_sum == right_sum:
      return i
    left_sum += l[i]
  return -1

# difference
nums1 = [1,2,3]
nums2 = [2,4,6]
def differences(l1,l2):
  first = []
  last =[]
  dif = list(set(l1) ^ set(l2))
  for i in dif:
    if i in nums1:
      first.append(i)
    else:
      last.append(i)
  return [first,last]

print(differences(nums1,nums2))
